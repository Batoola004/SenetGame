// Stick Class

import java.util.Random;

public class Stick {
    private char faceColor;
    private Random random = new Random();

    public Stick() {

    }

    // ØªØ§Ø¨Ø¹ Ù„Ø§Ø®ØªÙŠØ§Ø± Ù„ÙˆÙ† Ø§Ù„Ø¹ØµØ§ ÙØ§ØªØ­ Ø§Ùˆ ØºØ§Ù…Ù‚
    public char throwIt() {
        faceColor = random.nextBoolean() ? 'D' : 'L';
        return faceColor;
    }

    public char getFace() {
        return faceColor;
    }

    // ØªÙ…Ø«ÙŠÙ„ Ø§Ù„Ø´ÙƒÙ„
    public String getVisual() {
        if (faceColor == 'D') {
            return "â•¿";
        } else {
            return "â”‚";
        }
    }
}


//Throw Class

import java.util.Random;

public class Throw {
    private Stick[] sticks = new Stick[4];

    public Throw() {
        for (int i = 0; i < 4; i++)
            sticks[i] = new Stick();
    }

    public int makeThrow() {
        int total = 0;
        // Ù„Ø¹Ø¯ Ø§Ù„Ø¹ØµÙŠ Ø§Ù„ØºØ§Ù…Ù‚Ø©
        for (int i = 0; i < 4; i++) {
            if (sticks[i].throwIt() == 'D')
                total++;
        }
        // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ ÙˆØ§Ø±Ø¬Ø§Ø¹Ù‡
        if (total == 0)
            total = 5;
        return total;
    }
}

//Board class

public class Board {

    public static final int HUMAN = 1;
    public static final int AI = -1;
    public static final int EMPTY = 0;

    /**
     * Applies a move to the board.
     * move.from: 1-30 (square number)
     * move.to: 1-30 (square number) OR -1 (exiting the board)
     */
    public static void applyMove(int[] board, Move move, int player) {
        if (move.to == -1) {
            // Piece exits the board
            board[move.from - 1] = 0;
            return;
        }

        int fromIdx = move.from - 1;
        int toIdx = move.to - 1;
        int opponent = -player;

        // Check if landing on opponent's piece (swap positions)
        if (board[toIdx] == opponent && !Rules.isProtected(move.to)) {
            // Swap positions
            board[toIdx] = player;
            board[fromIdx] = opponent;
        } else {
            // Normal move
            board[toIdx] = player;
            board[fromIdx] = 0;
        }
    }
}

//Move Class

import java.util.*;

public class Move {
    public final int from;
    public final int to;

    public Move(int from, int to) {
        this.from = from;
        this.to = to;
    }

    // ØªØ§Ø¨Ø¹ Ù„Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„Ù…Ù…ÙƒÙ†Ø© Ù„Ù„Ø§Ø¹Ø¨ Ù„ÙŠØ®ØªØ§Ø± Ù…Ù†Ù‡Ù…
    @Override
    public String toString() {
        String fromStr = (from == 0) ? "Off-board" : "Sq" + from;
        String toStr = (to == -1) ? "Exited" : "Sq" + to;
        return fromStr + " â†’ " + toStr;
    }
}

//Rules Class

import java.util.*;

public class Rules {

    // Ø§Ø±Ù‚Ø§Ù… Ø§Ù„Ù…Ø±Ø¨Ø¹Ø§Øª Ø§Ù„Ù…Ù…ÙŠØ²Ø©
    public static final int HOUSE_OF_REBIRTH = 15;
    public static final int HOUSE_OF_HAPPINESS = 26;
    public static final int HOUSE_OF_WATER = 27;
    public static final int HOUSE_OF_THREE_TRUTHS = 28;
    public static final int HOUSE_OF_RE_ATUM = 29;
    public static final int HOUSE_OF_HORUS = 30;

    // ØªØ§Ø¨Ø¹ Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„Ù…Ù…ÙƒÙ†Ø© Ø­ÙŠØ« ÙŠØ£Ø®Ø° Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© ÙˆÙ…Ø§Ù‡Ùˆ Ø§Ù„Ù„Ø§Ø¹Ø¨ ÙˆÙ…Ø§Ù‡ÙŠ Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø±Ù…ÙŠ
    public static List<Move> getPossibleMoves(int[] board, int player, int roll) {
        List<Move> moves = new ArrayList<>();

        // ÙØ­Øµ Ù…Ø±Ø¨Ø¹Ø§Øª Ø§Ù„Ù„ÙˆØ­Ø©
        for (int i = 0; i < board.length; i++) {
            // Ø§Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø±Ø¨Ø¹ Ù„ÙŠØ³ ÙÙŠÙ‡ Ù‚Ø·Ø¹Ø© Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø°ÙŠ Ø¯ÙˆØ±Ù‡ Ø§Ù„Ø§Ù† Ù†ØªØ®Ø·Ø§Ù‡
            if (board[i] != player)
                continue;

            int from = i + 1; // ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø¤Ø´Ø± Ø¹Ù„Ù‰ Ø±Ù‚Ù… Ø§Ù„Ù…Ø±Ø¨Ø¹
            int to = from + roll; // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ù‡Ø¯Ù

            // Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„Ù‚ÙØ² ÙÙˆÙ‚ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø±Ø¨Ø¹ ÙŠØ¬Ø¨ Ø§Ù„ÙˆÙ‚ÙˆÙ Ø¹Ù„ÙŠÙ‡ Ø¨Ø§Ù„Ø¶Ø¨Ø·
            if (from < HOUSE_OF_HAPPINESS && to > HOUSE_OF_HAPPINESS) {
                continue;
            }

            // ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø±Ø¨Ø¹ Ù„Ø§ Ù†Ø³ØªØ·ÙŠØ¹ Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù†Ù‡ Ø§Ù„Ø§ Ø§Ø°Ø§ Ø­ØµÙ„Ù†Ø§ Ø¹Ù„Ù‰ 3 ÙÙŠ Ø§Ù„Ø±Ù…ÙŠØ©
            if (from == HOUSE_OF_THREE_TRUTHS) {
                if (roll == 3) {
                    moves.add(new Move(from, -1));
                }
                continue;
            }

            // ÙˆÙ‡Ù†Ø§ Ù†Ø®Ø±Ø¬ Ù…Ù†Ù‡ Ø¨Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø±Ù…ÙŠØªÙŠÙ†
            if (from == HOUSE_OF_RE_ATUM) {
                if (roll == 2) {
                    moves.add(new Move(from, -1));
                }
                continue;
            }

            // Ù†Ø®Ø±Ø¬ Ø¨Ø£ÙŠ Ø±Ù…ÙŠØ© Ù†Ø­ØµÙ„ Ø¹Ù„ÙŠÙ‡Ø§
            if (from == HOUSE_OF_HORUS) {
                moves.add(new Move(from, -1));
                continue;
            }

            // ÙØ­Øµ Ø§Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©
            if (to > BOARD_SIZE) {
                // ÙŠÙ…ÙƒÙ† Ø§Ù„Ø®Ø±ÙˆØ¬ Ø§Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù‚Ø·Ø¹Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ù…Ø±Ø¨Ø¹ 30
                if (from > HOUSE_OF_HAPPINESS) {
                    moves.add(new Move(from, -1));
                }
                continue;
            }

            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©
            if (isValid(board, player, to)) {
                moves.add(new Move(from, to));
            }
        }

        return moves;
    }

    // Ø­Ø¬Ù… Ø§Ù„Ù„ÙˆØ­Ø©
    private static final int BOARD_SIZE = 30;

    // ØªØ§Ø¨Ø¹ Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø§Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø­Ø±ÙƒØ© Ù…Ù…ÙƒÙ†Ø©
    private static boolean isValid(int[] board, int player, int sq) {
        int o = board[sq - 1];
        return o == 0 || (o != player && !isProtected(sq));
    }

    // ØªØ§Ø¨Ø¹ Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ø±Ø¨Ø¹Ø§Øª Ø§Ù„Ù…Ø­Ù…ÙŠØ© Ø§Ù„Ù…Ù…ÙŠØ²Ø©
    public static boolean isProtected(int sq) {
        // 15, 26, 28, 29, 30 are protected
        return sq == HOUSE_OF_REBIRTH ||
                sq == HOUSE_OF_HAPPINESS ||
                sq == HOUSE_OF_THREE_TRUTHS ||
                sq == HOUSE_OF_RE_ATUM ||
                sq == HOUSE_OF_HORUS;
    }

    // ØªØ§Ø¨Ø¹ Ø®Ø§Øµ Ø¨ØªØ£Ø«ÙŠØ± Ø§Ù„Ù‡Ø¨ÙˆØ· Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø±Ø¨Ø¹ 27 Ø§Ù„Ø°ÙŠ ÙŠÙ†Ù‚Ù„Ù†Ø§ Ø§Ù„Ù‰ Ø§Ù„Ù…Ø±Ø¨Ø¹ 15 Ù…Ø¨Ø§Ø´Ø±Ø©
    public static int applySpecialSquareEffect(int sq, int[] board) {
        if (sq == HOUSE_OF_WATER) {
            return HOUSE_OF_REBIRTH; // Send to 15
        }
        return sq;
    }
}

//AI Class

import java.util.List;

public class AI {

    // Ø§Ø­ØªÙ…Ø§Ù„Ø§Øª Ø¸Ù‡ÙˆØ± Ø§Ù„Ø§Ø±Ù‚Ø§Ù… Ø¹Ù†Ø¯ Ø±Ù…ÙŠ Ø§Ù„Ø¹ØµÙŠ
    private static final double P_1 = 0.25; // 1/4
    private static final double P_2 = 0.375; // 3/8
    private static final double P_3 = 0.25; // 1/4
    private static final double P_4 = 0.0625; // 1/16
    private static final double P_5 = 0.0625; // 1/16

    private int nodesVisited = 0;

    public Move getBestMove(int[] board, int roll, int depth) {
        nodesVisited = 0;
        Move bestMove = null;
        double bestValue = Double.NEGATIVE_INFINITY;// Ø£ÙØ¶Ù„ Ù‚ÙŠÙ…Ø© ÙˆÙ‡ÙŠ Ø£Ù‚Ù„ Ù‚ÙŠÙ…Ø©

        // Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„Ù…Ù…ÙƒÙ†Ø© Ø¨Ù†Ø§Ø¡ Ø¹Ù„Ù‰ Ø§Ù„Ø±Ù‚Ù… Ø§Ù„Ø°ÙŠ Ø¸Ù‡Ø± ÙÙŠ Ø±Ù…ÙŠ Ø§Ù„Ø¹ØµÙŠ
        List<Move> moves = Rules.getPossibleMoves(board, Board.AI, roll);

        // Ø§Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø­Ø±ÙƒØ§Øª Ù…Ù…ÙƒÙ†Ø© ÙŠØ±Ø¬Ø¹ null
        if (moves.isEmpty()) {
            return null;
        }

        for (Move move : moves) {
            // Ù†Ù†Ø³Ø® Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø¨Ø¹Ø¯ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø­Ø±ÙƒØ© Ù„ØªØ¬Ù†Ø¨ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ø§ØµÙ„ÙŠØ©
            int[] nextBoard = board.clone();
            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø­Ø±ÙƒØ© Ø¹Ù„Ù‰ Ø§Ù„Ø¨ÙˆØ±Ø¯
            Board.applyMove(nextBoard, move, Board.AI);

            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ©
            double value = expectiminimax(nextBoard, depth - 1, false, 0, Double.NEGATIVE_INFINITY,
                    Double.POSITIVE_INFINITY);

            if (value > bestValue) {
                bestValue = value;
                bestMove = move;
            }
        }

        // Ø§ÙØ¶Ù„ Ø­Ø±ÙƒØ© Ù„Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±
        return bestMove;
    }

    // Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ©
    public double expectiminimax(int[] board, int depth, boolean isMax, int fixedRoll, double alpha, double beta) {
        nodesVisited++;

        // Ø´Ø±ÙˆØ· Ø§Ù„ØªÙˆÙ‚Ù
        // Ø¥Ø°Ø§ ÙØ§Ø² Ø§Ù„Ø­Ø§Ø³ÙˆØ¨ : Ù‚ÙŠÙ…Ø© Ù…ÙˆØ¬Ø¨Ø© ÙƒØ¨ÙŠØ±Ø© + Ø§Ù„Ø¹Ù…Ù‚ (Ù„ØªØ´Ø¬ÙŠØ¹ Ø§Ù„ÙÙˆØ² Ø§Ù„Ø³Ø±ÙŠØ¹)
        if (hasWon(board, Board.AI))
            return 10000 + depth;
        // Ø¥Ø°Ø§ ÙØ§Ø² Ø§Ù„Ø¥Ù†Ø³Ø§Ù†: Ù‚ÙŠÙ…Ø© Ø³Ø§Ù„Ø¨Ø© ÙƒØ¨ÙŠØ±Ø© - Ø§Ù„Ø¹Ù…Ù‚ (Ù„Ø¹Ù‚Ø§Ø¨ Ø§Ù„Ø®Ø³Ø§Ø±Ø© Ø§Ù„Ø³Ø±ÙŠØ¹Ø©)
        if (hasWon(board, Board.HUMAN))
            return -10000 - depth;

        // Ø¥Ø°Ø§ ÙˆØµÙ„Ù†Ø§ Ù„Ø£Ù‚ØµÙ‰ Ø¹Ù…Ù‚: Ù†Ø±Ø¬Ø¹ ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
        if (depth == 0) {
            return evaluate(board);
        }

        // Ù†Ø­Ù† Ù„Ø§Ù†Ø¹Ø±Ù Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø±Ù…ÙŠØ© Ø§Ù„ØªØ§Ù„ÙŠØ© Ù„Ø°Ù„Ùƒ Ù†Ø­Ø³Ø¨ ÙØ±ØµØ© Ø¸Ù‡ÙˆØ± ÙƒÙ„ Ø§Ø­ØªÙ…Ø§Ù„ ÙˆØ°Ù„Ùƒ Ø¨Ø§Ù„Ù‚Ø§Ù†ÙˆÙ†
        // :Ù…Ø¬Ù…ÙˆØ¹ Ø§Ø­ØªÙ…Ø§Ù„Ø§Øª Ø§Ù„Ù†ØªØ§Ø¦Ø¬ *Ù‚ÙŠÙ…Ù‡Ø§
        if (fixedRoll == 0) {
            return P_1 * expectiminimax(board, depth - 1, isMax, 1, alpha, beta) +
                    P_2 * expectiminimax(board, depth - 1, isMax, 2, alpha, beta) +
                    P_3 * expectiminimax(board, depth - 1, isMax, 3, alpha, beta) +
                    P_4 * expectiminimax(board, depth - 1, isMax, 4, alpha, beta) +
                    P_5 * expectiminimax(board, depth - 1, isMax, 5, alpha, beta);
        }

        // Ù„Ù†Ø­Ø¯Ø¯ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ Ø§Ø°Ø§ ÙƒØ§Ù† Ù…Ø§ÙƒØ³ ÙØ§Ù„Ø­Ø§Ø³ÙˆØ¨ Ù‡Ùˆ Ø§Ù„Ø°ÙŠ ÙŠÙ„Ø¹Ø¨ ÙˆØ§Ù„Ø§ ÙŠÙƒÙˆÙ† Ø§Ù„Ø§Ù†Ø³Ø§Ù†
        int player = isMax ? Board.AI : Board.HUMAN;

        // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„Ù…Ù…ÙƒÙ†Ø© Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ Ù…Ø¹ Ø§Ù„Ø±Ù…ÙŠØ© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©
        List<Move> moves = Rules.getPossibleMoves(board, player, fixedRoll);

        // Ø¥Ø°Ø§ Ù„Ù… ØªÙˆØ¬Ø¯ Ø­Ø±ÙƒØ§Øª Ù†ØªØ®Ø·Ù‰ Ø§Ù„Ø¯ÙˆØ± ÙˆÙ†Ù†ØªÙ‚Ù„ Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø¢Ø®Ø±
        if (moves.isEmpty()) {

            // Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù„Ù„Ø¯ÙˆØ± Ø§Ù„ØªØ§Ù„ÙŠ Ù…Ø¹ Ø§Ù„Ø±Ù…ÙŠØ© ØºÙŠØ± Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© (0)
            return expectiminimax(board, depth - 1, !isMax, 0, alpha, beta);
        }

        // Ø§Ø°Ø§ ÙƒØ§Ù† Ø¯ÙˆØ± Ø§Ù„Ø­Ø§Ø³ÙˆØ¨ Ù†Ø¨Ø¯Ø£ Ù…Ù† Ø§Ù‚Ù„ Ù‚ÙŠÙ…Ø©
        if (isMax) {
            double value = Double.NEGATIVE_INFINITY;
            for (Move m : moves) {
                int[] nextBoard = board.clone();
                Board.applyMove(nextBoard, m, player);
                // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù‚ØµÙˆÙ‰
                value = Math.max(value, expectiminimax(nextBoard, depth - 1, false, 0, alpha, beta));
                // ØªØ­Ø¯ÙŠØ« Ø£Ù„ÙØ§
                alpha = Math.max(alpha, value);
                if (beta <= alpha)
                    break;
            }
            return value;
        } else
        // Ø¹Ù‚Ø¯Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø§Ù†Ø³Ø§Ù† Ù†Ø¨Ø¯Ø£ÙÙŠÙ‡ Ù…Ù† Ø§Ø¹Ù„Ù‰ Ù‚ÙŠÙ…Ø©
        {
            double value = Double.POSITIVE_INFINITY;
            for (Move m : moves) {
                int[] nextBoard = board.clone();
                Board.applyMove(nextBoard, m, player);
                value = Math.min(value, expectiminimax(nextBoard, depth - 1, true, 0, alpha, beta));
                beta = Math.min(beta, value);
                if (beta <= alpha)
                    break;
            }
            return value;
        }
    }

    // ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© ÙˆØ§Ø¹Ø·Ø§Ø¦Ù‡Ø§ Ù‚ÙŠÙ…Ø©
    // Ø§Ù„Ø¯Ø±Ø¬Ø© Ø§Ù„Ø§ÙŠØ¬Ø§Ø¨ÙŠØ© Ø¬ÙŠØ¯Ø© Ù„Ù„Ø­Ø§Ø³ÙˆØ¨
    // Ø§Ù„Ø¯Ø±Ø¬Ø© Ø§Ù„Ø³Ù„Ø¨ÙŠØ© Ø¬ÙŠØ¯Ø© Ù„Ù„Ø§Ù†Ø³Ø§Ù†
    private double evaluate(int[] board) {
        double score = 0;
        int aiPieces = 0;
        int humanPieces = 0;

        for (int piece : board) {
            if (piece == Board.AI)
                aiPieces++;
            else if (piece == Board.HUMAN)
                humanPieces++;
        }

        // Ø­Ø³Ø§Ø¨ Ù†Ù‚Ø§Ø· Ø¨Ù†Ø§Ø¡ Ø¹Ù„Ù‰ Ø¹Ø¯Ø¯ Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„ØªÙŠ Ø®Ø±Ø¬Øª
        score += (7 - humanPieces) * 100;
        score -= (7 - aiPieces) * 100;

        // Ù‡Ù† Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‚Ø§Ø· Ø¨Ù†Ø§Ø¡ Ø¹Ù„Ù‰ Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù‚Ø·Ø¹
        for (int i = 0; i < board.length; i++) {
            if (board[i] == Board.AI) {
                score += (i + 1);
                if (Rules.isProtected(i + 1))
                    score += 10;
                if (i > 0 && board[i - 1] == Board.AI)
                    score += 7;
            } else if (board[i] == Board.HUMAN) {
                score -= (i + 1);
                if (Rules.isProtected(i + 1))
                    score -= 10;
                if (i > 0 && board[i - 1] == Board.HUMAN)
                    score -= 7;
            }
        }
        return score;
    }

    // Ø§Ø°Ø§ Ù„Ù… ØªØ¨Ù‚Ù‰ Ù‚Ø·Ø¹ Ù„Ø§Ø¹Ø¨ Ù…Ø§ ÙÙŠ Ø§Ù„Ù„ÙˆØ­Ø© ÙÙ‡Ùˆ ÙŠÙÙˆØ²
    private boolean hasWon(int[] board, int player) {
        for (int b : board) {
            if (b == player)
                return false;
        }
        return true;
    }

    public int getNodesVisited() {
        return nodesVisited;
    }
}

//GameBoardPanel class


//ÙƒÙ„Ø§Ø³ ÙˆØ§Ø¬Ù‡Ø§Øª
import javax.swing.*;
import java.awt.*;
import java.awt.geom.*;

public class GameBoardPanel extends JPanel {
    private int[] currentBoard;
    private Color boardColor = new Color(205, 133, 63);
    private Color safeColor = new Color(154, 205, 50);
    private Color specialColor = new Color(218, 165, 32);
    private Color highlightColor = new Color(255, 215, 0, 128);
    private Move highlightedMove;

    public GameBoardPanel() {
        // Increased preferred size to accommodate larger squares
        setPreferredSize(new Dimension(1200, 850));
        setBackground(new Color(245, 222, 179));
        setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(new Color(139, 69, 19), 4),
                BorderFactory.createEmptyBorder(20, 20, 20, 20)));
    }

    public void setBoard(int[] board) {
        // System.out.println("DEBUG: setBoard called");
        if (board != null) {
            this.currentBoard = board.clone();
        }
        repaint();
    }

    public void highlightMove(Move move) {
        // System.out.println("DEBUG: highlighting move: " + move);
        this.highlightedMove = move;
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2d = (Graphics2D) g;
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        if (currentBoard == null)
            return;

        // Increased square size from 80 to 100 for better visibility
        int squareSize = 100;
        int spacing = 12;
        int startX = 50;

        // Draw the 3 rows of the Senet board
        drawBoardRow(g2d, 0, 9, startX, 120, true, squareSize, spacing);
        drawBoardRow(g2d, 19, 10, startX, 120 + squareSize + spacing, false, squareSize, spacing);
        drawBoardRow(g2d, 20, 29, startX, 120 + (squareSize + spacing) * 2, true, squareSize, spacing);

        drawTitle(g2d);
        drawLegend(g2d, startX, 550);
    }

    private void drawBoardRow(Graphics2D g2d, int start, int end, int x, int y, boolean leftToRight, int size,
            int spacing) {
        int direction = leftToRight ? 1 : -1;
        int xPos = x;

        for (int i = start; leftToRight ? i <= end : i >= end; i += direction) {
            drawSquare(g2d, i, xPos, y, size);
            xPos += size + spacing;
        }
    }

    private void drawSquare(Graphics2D g2d, int index, int x, int y, int size) {
        Color squareColor = getSquareColor(index);
        g2d.setColor(squareColor);
        g2d.fillRoundRect(x, y, size, size, 10, 10);

        g2d.setColor(Color.BLACK);
        g2d.setStroke(new BasicStroke(2));
        g2d.drawRoundRect(x, y, size, size, 10, 10);

        // Highlight logic
        if (highlightedMove != null) {
            int fromIdx = highlightedMove.from - 1;
            int toIdx = (highlightedMove.to == -1) ? -1 : highlightedMove.to - 1;

            if ((fromIdx == index || toIdx == index) && fromIdx >= 0) {
                g2d.setColor(highlightColor);
                g2d.fillRoundRect(x, y, size, size, 10, 10);
            }
        }

        // Draw square number - increased font size
        g2d.setColor(Color.BLACK);
        g2d.setFont(new Font("Arial", Font.BOLD, 18));
        g2d.drawString(String.valueOf(index + 1), x + 10, y + 25);

        // Draw piece if present
        if (index >= 0 && index < currentBoard.length && currentBoard[index] != 0) {
            drawPiece(g2d, x, y, size, currentBoard[index]);
        }

        // Labels for special squares with rules mentioned
        drawSpecialLabel(g2d, x, y, size, index + 1);
    }

    private Color getSquareColor(int index) {
        int sq = index + 1;
        if (sq == 26 || sq == 28 || sq == 29 || sq == 30)
            return specialColor;
        if (sq == 15 || sq == 27)
            return safeColor;
        return boardColor;
    }

    private void drawPiece(Graphics2D g2d, int x, int y, int size, int player) {
        int pSize = size - 40;
        int cx = x + size / 2;
        int cy = y + size / 2;

        if (player == 1) { // Human
            g2d.setColor(new Color(30, 144, 255));
            g2d.fillOval(cx - pSize / 2, cy - pSize / 2, pSize, pSize);
            g2d.setColor(Color.WHITE);
            g2d.setFont(new Font("Arial", Font.BOLD, 24)); // Bigger text on piece
            g2d.drawString("H", cx - 9, cy + 9);
        } else if (player == -1) { // AI
            g2d.setColor(new Color(220, 20, 60));
            g2d.fillOval(cx - pSize / 2, cy - pSize / 2, pSize, pSize);
            g2d.setColor(Color.WHITE);
            g2d.setFont(new Font("Arial", Font.BOLD, 20));
            g2d.drawString("AI", cx - 11, cy + 8);
        }
    }

    private void drawSpecialLabel(Graphics2D g2d, int x, int y, int size, int square) {
        g2d.setColor(new Color(40, 40, 40));
        g2d.setFont(new Font("Arial", Font.BOLD, 12)); // Bolded for better readability

        String line1 = "";
        String line2 = "";

        switch (square) {
            case 15:
                line1 = "REBIRTH";
                break;
            case 26:
                line1 = "HAPPINESS";
                line2 = "Landed exactly";
                break;
            case 27:
                line1 = "WATER";
                line2 = "Go to 15";
                break;
            case 28:
                line1 = "3 TRUTHS";
                line2 = "Need 3 to exit";
                break;
            case 29:
                line1 = "RE-ATUM";
                line2 = "Need 2 to exit";
                break;
            case 30:
                line1 = "HORUS";
                line2 = "Need 1 to exit";
                break;
        }

        if (!line1.isEmpty()) {
            FontMetrics fm = g2d.getFontMetrics();
            int l1x = x + (size - fm.stringWidth(line1)) / 2;
            g2d.drawString(line1, l1x, y + size - 25);

            if (!line2.isEmpty()) {
                g2d.setFont(new Font("Arial", Font.PLAIN, 10));
                int l2x = x + (size - g2d.getFontMetrics().stringWidth(line2)) / 2;
                g2d.drawString(line2, l2x, y + size - 10);
            }
        }
    }

    private void drawTitle(Graphics2D g2d) {
        g2d.setFont(new Font("Serif", Font.BOLD, 36)); // Increased title size
        g2d.setColor(new Color(139, 69, 19));
        g2d.drawString("SENET - ANCIENT EGYPTIAN BOARD", 50, 60);
    }

    private void drawLegend(Graphics2D g2d, int x, int y) {
        y += 50; // Offset from the board
        g2d.setFont(new Font("Arial", Font.BOLD, 20));
        g2d.setColor(Color.BLACK);
        g2d.drawString("Rules & Info:", x, y);

        g2d.setFont(new Font("Arial", Font.PLAIN, 16));
        g2d.drawString("- Blue (H): Human player pieces", x, y + 30);
        g2d.drawString("- Red (AI): Computer opponent pieces", x, y + 60);
        g2d.drawString("- Gold Squares (26-30): The final stretch. Follow specific exit rolls.", x + 400, y + 30);
        g2d.drawString("- Green Squares (15, 27): House of Rebirth (Safe) and House of Water (Trap).", x + 400, y + 60);

        // System.out.println("DEBUG: Legend rendered");
    }
}

//InfoPanel class

//ÙƒÙ„Ø§Ø³ ÙˆØ§Ø¬Ù‡Ø§Øª
import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.event.*;
import java.beans.*;
import java.time.format.DateTimeFormatter;

public class InfoPanel extends JPanel {
    private JLabel diceLabel;
    private JLabel playerLabel;
    private JLabel humanScoreLabel;
    private JLabel aiScoreLabel;
    private JLabel aiEvaluationLabel;
    private JTextArea messageArea;
    private JScrollPane scrollPane;

    public InfoPanel() {
        setLayout(new BorderLayout(15, 15));
        setBackground(new Color(245, 222, 179));
        setBorder(createBorder());
        setPreferredSize(new Dimension(0, 200)); // Increased height

        initializeComponents();
    }

    private Border createBorder() {
        return BorderFactory.createCompoundBorder(
                BorderFactory.createTitledBorder(
                        BorderFactory.createLineBorder(new Color(139, 69, 19), 3),
                        "Game Information",
                        TitledBorder.LEFT,
                        TitledBorder.TOP,
                        new Font("Arial", Font.BOLD, 16),
                        new Color(139, 69, 19)),
                BorderFactory.createEmptyBorder(15, 15, 15, 15));
    }

    private void initializeComponents() {
        // Top panel for scores and player info
        JPanel topPanel = new JPanel(new GridLayout(2, 3, 10, 10));
        topPanel.setBackground(new Color(245, 222, 179));

        playerLabel = new JLabel("Current Player: Human", SwingConstants.CENTER);
        playerLabel.setFont(new Font("Arial", Font.BOLD, 18));
        playerLabel.setForeground(new Color(34, 139, 34));
        topPanel.add(playerLabel);

        diceLabel = new JLabel("Last Roll: -", SwingConstants.CENTER);
        diceLabel.setFont(new Font("Arial", Font.BOLD, 20));
        diceLabel.setForeground(new Color(139, 69, 19));
        topPanel.add(diceLabel);

        // Game status panel
        JPanel statusPanel = new JPanel(new GridLayout(2, 1, 5, 5));
        statusPanel.setBackground(new Color(245, 222, 179));

        humanScoreLabel = new JLabel("Human Pieces Exited: 0/5", SwingConstants.CENTER);
        humanScoreLabel.setFont(new Font("Arial", Font.BOLD, 14));
        humanScoreLabel.setForeground(Color.BLUE);
        statusPanel.add(humanScoreLabel);

        aiScoreLabel = new JLabel("AI Pieces Exited: 0/5", SwingConstants.CENTER);
        aiScoreLabel.setFont(new Font("Arial", Font.BOLD, 14));
        aiScoreLabel.setForeground(Color.RED);
        statusPanel.add(aiScoreLabel);

        topPanel.add(statusPanel);

        add(topPanel, BorderLayout.NORTH);

        // AI Evaluation panel
        JPanel evalPanel = new JPanel();
        evalPanel.setBackground(new Color(245, 222, 179));
        evalPanel.setLayout(new BoxLayout(evalPanel, BoxLayout.Y_AXIS));

        JLabel evalTitle = new JLabel("AI Evaluation:");
        evalTitle.setFont(new Font("Arial", Font.BOLD, 16));
        evalTitle.setForeground(new Color(139, 69, 19));
        evalPanel.add(evalTitle);

        aiEvaluationLabel = new JLabel("Waiting for AI to think...");
        aiEvaluationLabel.setFont(new Font("Monospaced", Font.BOLD, 14));
        aiEvaluationLabel.setForeground(new Color(178, 34, 34));
        evalPanel.add(aiEvaluationLabel);

        add(evalPanel, BorderLayout.CENTER);

        // Message area
        messageArea = new JTextArea(4, 50);
        messageArea.setEditable(false);
        messageArea.setFont(new Font("Monospaced", Font.PLAIN, 14));
        messageArea.setBackground(new Color(255, 250, 240)); // Floral White
        messageArea.setForeground(new Color(101, 67, 33)); // Dark Brown
        messageArea.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(new Color(184, 134, 11), 2),
                BorderFactory.createEmptyBorder(10, 10, 10, 10)));

        scrollPane = new JScrollPane(messageArea);
        scrollPane.setBorder(BorderFactory.createTitledBorder(
                BorderFactory.createLineBorder(new Color(139, 69, 19), 2),
                "Game Log",
                TitledBorder.LEFT,
                TitledBorder.TOP,
                new Font("Arial", Font.BOLD, 14),
                new Color(139, 69, 19)));

        add(scrollPane, BorderLayout.SOUTH);
    }

    public void updateInfo(int currentPlayer, int humanExited, int aiExited) {
        String playerText = currentPlayer == Board.HUMAN ? "Human" : "AI";
        Color playerColor = currentPlayer == Board.HUMAN ? new Color(34, 139, 34) : new Color(178, 34, 34);

        playerLabel.setText("Current Player: " + playerText);
        playerLabel.setForeground(playerColor);

        humanScoreLabel.setText("Human Pieces Exited: " + humanExited + "/5");
        aiScoreLabel.setText("AI Pieces Exited: " + aiExited + "/5");

        // Update background color based on whose turn it is
        setBackground(currentPlayer == Board.HUMAN ? new Color(245, 222, 179, 200) : new Color(255, 228, 181, 200)); // Lighter
                                                                                                                     // background
                                                                                                                     // for
                                                                                                                     // AI
                                                                                                                     // turn
    }

    public void setDiceRoll(int roll) {
        diceLabel.setText("Last Roll: " + roll);
        diceLabel.setForeground(new Color(255, 69, 0)); // Orange Red

        // Flash effect
        Timer flashTimer = new Timer(300, e -> {
            diceLabel.setForeground(new Color(139, 69, 19));
        });
        flashTimer.setRepeats(false);
        flashTimer.start();

        // Log the roll
        showMessage("ğŸ² Dice rolled: " + roll);
    }

    public void setAIEvaluation(double evaluation, int nodesVisited) {
        String evalText = String.format("Value: %.2f | Nodes: %d", evaluation, nodesVisited);
        aiEvaluationLabel.setText(evalText);

        // Color code based on evaluation value
        if (evaluation > 100) {
            aiEvaluationLabel.setForeground(new Color(34, 139, 34)); // Green - AI is winning
        } else if (evaluation < -100) {
            aiEvaluationLabel.setForeground(new Color(178, 34, 34)); // Red - AI is losing
        } else {
            aiEvaluationLabel.setForeground(new Color(139, 69, 19)); // Brown - neutral
        }

        // Show thinking animation
        aiEvaluationLabel.setText("ğŸ§  AI thinking...");
        Timer thinkingTimer = new Timer(1000, e -> {
            aiEvaluationLabel.setText(evalText);
        });
        thinkingTimer.setRepeats(false);
        thinkingTimer.start();
    }

    public void showMessage(String message) {
        String timestamp = java.time.LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm:ss"));
        messageArea.append("[" + timestamp + "] " + message + "\n");
        messageArea.setCaretPosition(messageArea.getDocument().getLength());

        // Auto-scroll to bottom
        SwingUtilities.invokeLater(() -> {
            scrollPane.getVerticalScrollBar().setValue(
                    scrollPane.getVerticalScrollBar().getMaximum());
        });
    }

    public void clearMessages() {
        messageArea.setText("");
        showMessage("Game started. Human begins.");
    }

    public void showWinMessage(String winner) {
        String winMessage = "ğŸ† " + winner + " WINS! All pieces have exited the board!";
        showMessage(winMessage);

        // Flash win message
        Timer flashTimer = new Timer(500, new ActionListener() {
            boolean on = true;
            int count = 0;

            public void actionPerformed(ActionEvent e) {
                if (count > 6) {
                    ((Timer) e.getSource()).stop();
                    return;
                }
                playerLabel.setForeground(on ? Color.GREEN : Color.YELLOW);
                on = !on;
                count++;
            }
        });
        flashTimer.start();
    }

}

//SenetGame class

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.TitledBorder;
import java.awt.*;
import java.awt.event.*;
import java.util.List;

public class SenetGame {
    private JFrame mainFrame;
    private GameBoardPanel boardPanel;
    private ControlPanel controlPanel;
    private InfoPanel infoPanel;
    private int[] board;
    private int currentPlayer = Board.HUMAN;
    private int humanExited = 0;
    private int aiExited = 0;
    private final int TOTAL_PIECES = 5;
    private AI ai = new AI();
    private final int AI_DEPTH = 4;
    private Throw sticks = new Throw();
    private Timer aiTimer;
    private boolean gameActive = true;
    private boolean aiThinking = false;
    private boolean canHumanRoll = true; // Ù…ØªØºÙŠØ± Ù„Ù…Ù†Ø¹ Ø§Ù„Ø±Ù…ÙŠ Ø§Ù„Ù…ØªØ¹Ø¯Ø¯ ÙÙŠ Ù†ÙØ³ Ø§Ù„Ø¯ÙˆØ±

    // Ø­Ø¬Ù… Ù„ÙˆØ­Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© (30 Ù…Ø±Ø¨Ø¹)
    private static final int BOARD_SIZE = 30;

    public SenetGame() {
        initializeBoard(); // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù„ÙˆØ­Ø©
        initializeUI(); // Ø¨Ù†Ø§Ø¡ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©
        startGame(); // Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
    }

    // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠØ© Ù„Ù„ÙˆØ­Ø©
    private void initializeBoard() {
        board = new int[BOARD_SIZE];
        for (int i = 0; i < 14; i++) {
            board[i] = (i % 2 == 0) ? Board.HUMAN : Board.AI;
        }
    }

    // Ø¨Ù†Ø§Ø¡ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
    private void initializeUI() {
        mainFrame = new JFrame("Senet - Ancient Egyptian Board Game");
        mainFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        mainFrame.setLayout(new BorderLayout(15, 15));

        Color bgColor = new Color(245, 222, 179);
        mainFrame.getContentPane().setBackground(bgColor);

        boardPanel = new GameBoardPanel();
        controlPanel = new ControlPanel(this);
        infoPanel = new InfoPanel();

        mainFrame.add(boardPanel, BorderLayout.CENTER);
        mainFrame.add(controlPanel, BorderLayout.EAST);
        mainFrame.add(infoPanel, BorderLayout.SOUTH);

        mainFrame.setSize(1400, 950);
        mainFrame.setMinimumSize(new Dimension(1200, 800));
        mainFrame.setLocationRelativeTo(null);

        mainFrame.addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {
                if (aiTimer != null && aiTimer.isRunning()) {
                    aiTimer.stop();
                }
            }
        });

        mainFrame.setVisible(true);

        // Ù…Ø¤Ù‚Øª Ù„Ø¯ÙˆØ± Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ (ÙŠØ´ØªØºÙ„ Ø¨Ø¹Ø¯ Ø«Ø§Ù†ÙŠØ© ÙˆØ§Ø­Ø¯Ø©)
        aiTimer = new Timer(1000, e -> {
            aiThinking = false;
            if (gameActive && currentPlayer == Board.AI) {
                executeAITurn();
            }
        });
        aiTimer.setRepeats(false);
    }

    // Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø© ÙˆØ¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠØ©
    private void startGame() {
        updateBoardDisplay();
        updateInfoPanel();
        controlPanel.setGameControlsEnabled(true);
        controlPanel.setRollButtonEnabled(true);
        infoPanel.clearMessages();
        infoPanel.showMessage("Game started. Human player begins.");
        infoPanel.showMessage("Rules: First to exit all 5 pieces wins.");
    }

    // ØªØ­Ø¯ÙŠØ« Ø¹Ø±Ø¶ Ø§Ù„Ù„ÙˆØ­Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø©
    public void updateBoardDisplay() {
        boardPanel.setBoard(board);
        boardPanel.repaint();
    }

    // ØªØ­Ø¯ÙŠØ« Ù„ÙˆØ­Ø© Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª (Ø¯ÙˆØ± Ø§Ù„Ù„Ø§Ø¹Ø¨ ÙˆØ§Ù„Ù‚Ø·Ø¹ Ø§Ù„Ø®Ø§Ø±Ø¬Ø©)
    private void updateInfoPanel() {
        infoPanel.updateInfo(currentPlayer, humanExited, aiExited);
    }

    // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø±Ù…ÙŠ Ø§Ù„Ø¹ØµÙŠ Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø¥Ù†Ø³Ø§Ù†
    public void rollDiceForHuman() {
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø´Ø±ÙˆØ· Ù‚Ø¨Ù„ Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ø±Ù…ÙŠ
        if (!gameActive) {
            infoPanel.showMessage("Game is not active. Please reset.");
            return;
        }

        if (currentPlayer != Board.HUMAN) {
            infoPanel.showMessage("It's not your turn. Please wait for AI.");
            return;
        }

        if (aiThinking) {
            infoPanel.showMessage("AI is thinking. Please wait.");
            return;
        }

        if (!canHumanRoll) {
            infoPanel.showMessage("You have already rolled this turn. Make a move first.");
            return;
        }

        // Ù…Ù†Ø¹ Ø§Ù„Ø±Ù…ÙŠ Ø§Ù„Ù…ØªØ¹Ø¯Ø¯ ÙÙŠ Ù†ÙØ³ Ø§Ù„Ø¯ÙˆØ±
        canHumanRoll = false;
        controlPanel.setRollButtonEnabled(false);

        int roll = sticks.makeThrow();
        infoPanel.setDiceRoll(roll);
        infoPanel.showMessage("Human rolled: " + roll);

        List<Move> moves = Rules.getPossibleMoves(board, currentPlayer, roll);

        if (moves.isEmpty()) {
            infoPanel.showMessage("No valid moves. Turn skipped.");
            handleUnplayedSpecialPieces(Board.HUMAN, null);
            updateBoardDisplay();
            switchTurn();
        } else {
            controlPanel.showMoveButtons(moves);
            infoPanel.showMessage("Found " + moves.size() + " valid moves.");
        }
    }

    // ØªÙ†ÙÙŠØ° Ø­Ø±ÙƒØ© Ø§Ù„Ø¥Ù†Ø³Ø§Ù† Ø§Ù„Ù…Ø®ØªØ§Ø±Ø©
    public void executeHumanMove(Move move) {
        if (!gameActive) {
            infoPanel.showMessage("Warning: Cannot move - game is inactive");
            return;
        }

        performMoveLogic(move, Board.HUMAN);
        handleUnplayedSpecialPieces(Board.HUMAN, move);
        updateBoardDisplay();
        checkGameEnd();

        if (gameActive) {
            switchTurn();
        }
    }

    // ØªÙ†ÙÙŠØ° Ø¯ÙˆØ± Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
    private void executeAITurn() {
        if (!gameActive || currentPlayer != Board.AI || aiThinking) {
            return;
        }

        aiThinking = true;
        infoPanel.showMessage("AI is thinking...");

        int roll = sticks.makeThrow();
        infoPanel.setDiceRoll(roll);
        infoPanel.showMessage("AI rolled: " + roll);

        Move aiMove = ai.getBestMove(board, roll, AI_DEPTH);

        if (aiMove != null) {
            infoPanel.showMessage("AI chose: " + aiMove);
            performMoveLogic(aiMove, Board.AI);
            handleUnplayedSpecialPieces(Board.AI, aiMove);
        } else {
            infoPanel.showMessage("AI has no valid moves. Turn skipped.");
            handleUnplayedSpecialPieces(Board.AI, null);
        }

        updateBoardDisplay();
        checkGameEnd();

        aiThinking = false;
        if (gameActive) {
            switchTurn();
        }
    }

    // ------ Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„Ù…Ù†Ø·Ù‚ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ ------

    // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…Ù†Ø·Ù‚ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ Ù„Ù„Ø­Ø±ÙƒØ©
    private void performMoveLogic(Move move, int player) {
        boardPanel.highlightMove(move);
        Board.applyMove(board, move, player);

        if (move.to == -1) {
            if (player == Board.HUMAN)
                humanExited++;
            else
                aiExited++;
            infoPanel.showMessage((player == Board.HUMAN ? "Human" : "AI") + " piece exited!");
        } else {
            int effect = Rules.applySpecialSquareEffect(move.to, board);
            if (effect != move.to) {
                sendPieceToRebirthOrBefore(move.to, player);
            }
        }
    }

    // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ Ø§Ù„Ù…Ø±Ø¨Ø¹Ø§Øª Ø§Ù„Ø®Ø§ØµØ© (28ØŒ 29ØŒ 30) Ø§Ù„ØªÙŠ Ù„Ù… ØªÙ„Ø¹Ø¨
    private void handleUnplayedSpecialPieces(int player, Move moveJustMade) {
        int[] specialSquares = { Rules.HOUSE_OF_THREE_TRUTHS, Rules.HOUSE_OF_RE_ATUM, Rules.HOUSE_OF_HORUS };

        for (int sq : specialSquares) {
            int idx = sq - 1;
            if (board[idx] == player) {
                if (moveJustMade != null && moveJustMade.to == sq) {
                    continue; // Ø¢Ù…Ù†Ø©ØŒ ÙˆØµÙ„Øª Ù„Ù„ØªÙˆ
                }

                infoPanel.showMessage("Piece on Square " + sq + " failed to exit and drowns!");
                sendPieceToRebirthOrBefore(sq, player);
            }
        }
    }

    // Ø¥Ø±Ø³Ø§Ù„ Ù‚Ø·Ø¹Ø© Ø¥Ù„Ù‰ Ø¨ÙŠØª Ø§Ù„ÙˆÙ„Ø§Ø¯Ø© (15) Ø£Ùˆ Ø£Ù‚Ø±Ø¨ Ù…Ø±Ø¨Ø¹ ÙØ§Ø±Øº Ù‚Ø¨Ù„Ù‡
    private void sendPieceToRebirthOrBefore(int currentSquare, int player) {
        int targetIdx = Rules.HOUSE_OF_REBIRTH - 1;

        while (targetIdx >= 0 && board[targetIdx] != 0) {
            targetIdx--;
        }

        if (targetIdx >= 0) {
            board[currentSquare - 1] = 0;
            board[targetIdx] = player;
            String pName = (player == Board.HUMAN) ? "Human" : "AI";
            infoPanel.showMessage(pName + " piece relocated to Square " + (targetIdx + 1));
        }
    }

    // ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ø¯ÙˆØ± Ø¨ÙŠÙ† Ø§Ù„Ø¥Ù†Ø³Ø§Ù† ÙˆØ§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
    private void switchTurn() {
        if (!gameActive)
            return;

        infoPanel.showMessage("Switching turn...");
        currentPlayer = -currentPlayer;
        canHumanRoll = (currentPlayer == Board.HUMAN); // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø­Ø§Ù„Ø© Ø§Ù„Ø±Ù…ÙŠ

        controlPanel.clearMoveButtons();
        updateInfoPanel();

        if (currentPlayer == Board.AI && gameActive) {
            controlPanel.setGameControlsEnabled(false);
            controlPanel.setRollButtonEnabled(false);
            aiThinking = true;
            aiTimer.start();
        } else if (currentPlayer == Board.HUMAN && gameActive) {
            controlPanel.setGameControlsEnabled(true);
            controlPanel.setRollButtonEnabled(true);
            infoPanel.showMessage("Human turn - click Roll Sticks");
        }
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù„Ø¹Ø¨Ø© (ÙÙˆØ² Ø£Ø­Ø¯ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†)
    private void checkGameEnd() {
        if (humanExited >= TOTAL_PIECES) {
            infoPanel.showMessage("HUMAN WINS! All pieces exited!");
            gameActive = false;
            controlPanel.setGameControlsEnabled(false);
            controlPanel.setRollButtonEnabled(false);
            infoPanel.showWinMessage("HUMAN");
        } else if (aiExited >= TOTAL_PIECES) {
            infoPanel.showMessage("AI WINS! All pieces exited!");
            gameActive = false;
            controlPanel.setGameControlsEnabled(false);
            controlPanel.setRollButtonEnabled(false);
            infoPanel.showWinMessage("AI");
        }
    }

    // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠØ©
    public void resetGame() {
        if (aiTimer != null && aiTimer.isRunning()) {
            aiTimer.stop();
        }

        aiThinking = false;
        gameActive = true;
        initializeBoard();
        currentPlayer = Board.HUMAN;
        humanExited = 0;
        aiExited = 0;
        canHumanRoll = true;

        updateBoardDisplay();
        updateInfoPanel();
        controlPanel.clearMoveButtons();
        controlPanel.setGameControlsEnabled(true);
        controlPanel.setRollButtonEnabled(true);
        infoPanel.clearMessages();
        boardPanel.highlightMove(null);

        infoPanel.showMessage("Game reset. Human player starts.");
    }

    // Ù†Ù‚Ø·Ø© Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ù„Ø¹Ø¨Ø©
    public static void launchGame() {
        SwingUtilities.invokeLater(() -> {
            try {
                UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
            } catch (Exception e) {
            }
            new SenetGame();
        });
    }
}

//SquareButton class

//ÙƒÙ„Ø§Ø³ ÙˆØ§Ø¬Ù‡Ø§Øª
import javax.swing.*;
import java.awt.*;

public class SquareButton extends JButton {
    private int squareNumber;
    private int occupant;
    private boolean isSpecial;
    private boolean isSafe;

    public SquareButton(int squareNumber, int occupant) {
        this.squareNumber = squareNumber;
        this.occupant = occupant;
        this.isSpecial = isSpecialSquare(squareNumber);
        this.isSafe = isSafeSquare(squareNumber);

        initializeButton();
    }

    private void initializeButton() {
        setPreferredSize(new Dimension(60, 60));
        setFont(new Font("Arial", Font.BOLD, 12));

        setBackground(getButtonColor());
        setText(getButtonText());
        setForeground(getTextColor());

        setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(Color.BLACK, 1),
                BorderFactory.createEmptyBorder(5, 5, 5, 5)));

        setFocusPainted(false);
    }

    private Color getButtonColor() {
        if (isSpecial) {
            return new Color(218, 165, 32);
        } else if (isSafe) {
            return new Color(154, 205, 50);
        } else {
            return new Color(205, 133, 63);
        }
    }

    private Color getTextColor() {
        if (occupant != Board.EMPTY) {
            return Color.WHITE;
        }
        return Color.BLACK;
    }

    private String getButtonText() {
        if (occupant == Board.HUMAN) {
            return "H";
        } else if (occupant == Board.AI) {
            return "AI";
        }
        return String.valueOf(squareNumber);
    }

    private boolean isSpecialSquare(int square) {
        return square == Rules.HOUSE_OF_HAPPINESS ||
                square == Rules.HOUSE_OF_THREE_TRUTHS ||
                square == Rules.HOUSE_OF_RE_ATUM ||
                square == Rules.HOUSE_OF_HORUS;
    }

    private boolean isSafeSquare(int square) {
        return square == Rules.HOUSE_OF_REBIRTH ||
                square == Rules.HOUSE_OF_WATER;
    }

    public void setOccupant(int occupant) {
        this.occupant = occupant;
        setText(getButtonText());
        setForeground(getTextColor());
        repaint();
    }

    public int getSquareNumber() {
        return squareNumber;
    }

    public int getOccupant() {
        return occupant;
    }
}